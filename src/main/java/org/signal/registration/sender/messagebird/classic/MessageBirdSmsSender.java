/*
 * Copyright 2022 Signal Messenger, LLC
 * SPDX-License-Identifier: AGPL-3.0-only
 */

package org.signal.registration.sender.messagebird.classic;

import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber;
import com.google.protobuf.InvalidProtocolBufferException;
import com.messagebird.MessageBirdClient;
import com.messagebird.exceptions.MessageBirdException;
import com.messagebird.objects.DataCodingType;
import com.messagebird.objects.Message;
import com.messagebird.objects.MessageResponse;
import io.micrometer.core.instrument.Timer;
import jakarta.inject.Singleton;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.time.Duration;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import org.apache.commons.lang3.StringUtils;
import org.signal.registration.sender.ApiClientInstrumenter;
import org.signal.registration.sender.AttemptData;
import org.signal.registration.sender.ClientType;
import org.signal.registration.sender.MessageTransport;
import org.signal.registration.sender.SenderIdSelector;
import org.signal.registration.sender.SenderRejectedRequestException;
import org.signal.registration.sender.UnsupportedMessageTransportException;
import org.signal.registration.sender.VerificationCodeGenerator;
import org.signal.registration.sender.VerificationCodeSender;
import org.signal.registration.sender.VerificationSmsBodyProvider;
import org.signal.registration.sender.messagebird.MessageBirdClassicSessionData;
import org.signal.registration.sender.messagebird.MessageBirdExceptions;
import org.signal.registration.sender.messagebird.MessageBirdSenderConfiguration;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Sends messages through the MessageBird SMS API
 * <p>
 * The <a href="https://developers.messagebird.com/api/sms-messaging/#sms-api">MessageBird SMS API</a> sends arbitrary
 * SMS messages. Verification codes are generated by this class and added to the message text, then later verified
 * through the previously stored session.
 */
@Singleton
public class MessageBirdSmsSender implements VerificationCodeSender {

  private static final Logger logger = LoggerFactory.getLogger(MessageBirdSmsSender.class);

  private final MessageBirdSmsConfiguration configuration;
  private final VerificationCodeGenerator verificationCodeGenerator;
  private final VerificationSmsBodyProvider verificationSmsBodyProvider;
  private final MessageBirdClient client;
  private final ApiClientInstrumenter apiClientInstrumenter;
  private final SenderIdSelector senderIdSelector;
  public static final String SENDER_NAME = "messagebird-sms";

  public MessageBirdSmsSender(
      final MessageBirdSmsConfiguration configuration,
      final VerificationCodeGenerator verificationCodeGenerator,
      final VerificationSmsBodyProvider verificationSmsBodyProvider,
      final MessageBirdClient messageBirdClient,
      final ApiClientInstrumenter apiClientInstrumenter,
      final MessageBirdSenderConfiguration senderConfiguration) {
    this.configuration = configuration;
    this.verificationCodeGenerator = verificationCodeGenerator;
    this.verificationSmsBodyProvider = verificationSmsBodyProvider;
    this.client = messageBirdClient;
    this.apiClientInstrumenter = apiClientInstrumenter;
    this.senderIdSelector = new SenderIdSelector(senderConfiguration.senderIdsByRegion(), senderConfiguration.defaultSenderId());
  }

  @Override
  public String getName() {
    return SENDER_NAME;
  }

  @Override
  public Duration getAttemptTtl() {
    return this.configuration.sessionTtl();
  }

  @Override
  public boolean supportsTransport(final MessageTransport transport) {
    return transport == MessageTransport.SMS;
  }

  @Override
  public boolean supportsLanguage(final MessageTransport messageTransport,
      final Phonenumber.PhoneNumber phoneNumber,
      final List<Locale.LanguageRange> languageRanges) {

    return verificationSmsBodyProvider.supportsLanguage(languageRanges);
  }

  @Override
  public AttemptData sendVerificationCode(final MessageTransport messageTransport,
      final Phonenumber.PhoneNumber phoneNumber, final List<Locale.LanguageRange> languageRanges,
      final ClientType clientType) throws SenderRejectedRequestException {

    if (messageTransport != MessageTransport.SMS) {
      throw new UnsupportedMessageTransportException();
    }

    final String e164 = PhoneNumberUtil.getInstance().format(phoneNumber, PhoneNumberUtil.PhoneNumberFormat.E164);

    final String verificationCode = verificationCodeGenerator.generateVerificationCode();
    final String body = this.verificationSmsBodyProvider.getVerificationBody(
        phoneNumber,
        clientType,
        verificationCode,
        languageRanges);
    final Message message = new Message(senderIdSelector.getSenderId(phoneNumber), body, e164);
    message.setDatacoding(DataCodingType.auto);
    message.setValidity((int) getAttemptTtl().toSeconds());

    final Timer.Sample sample = Timer.start();

    try {
      final MessageResponse messageResponse = this.client.sendMessage(message);
      logger.debug("Sent {}, {}, {}", messageResponse, messageResponse.getRecipients(),
          messageResponse.getRecipients().getTotalDeliveryFailedCount());

      if (messageResponse.getRecipients().getTotalDeliveryFailedCount() != 0) {
        throw new SenderRejectedRequestException("Failed to deliver message");
      }

      apiClientInstrumenter.recordApiCallMetrics(
          getName(),
          "sms.create",
          true,
          null,
          sample);

      return new AttemptData(Optional.of(messageResponse.getId()),
          MessageBirdClassicSessionData.newBuilder().setVerificationCode(verificationCode).build().toByteArray());
    } catch (final MessageBirdException e) {
      logger.debug("Failed verification with {}, errors={}", e.getMessage(), e.getErrors());

      apiClientInstrumenter.recordApiCallMetrics(
          getName(),
          "sms.create",
          false,
          MessageBirdExceptions.extract(e),
          sample);

      throw MessageBirdExceptions.toSenderRejectedException(e)
          .orElseThrow(() -> new UncheckedIOException(new IOException(e)));
    } catch (final SenderRejectedRequestException | RuntimeException e) {
      logger.debug("Failed to send SMS message with {}", e.getMessage());

      apiClientInstrumenter.recordApiCallMetrics(
          getName(),
          "sms.create",
          false,
          MessageBirdExceptions.extract(e),
          sample);

      throw e;
    }
  }

  @Override
  public boolean checkVerificationCode(final String verificationCode, final byte[] senderData) {
    try {
      final String storedVerificationCode = MessageBirdClassicSessionData.parseFrom(senderData).getVerificationCode();
      return StringUtils.equals(verificationCode, storedVerificationCode);
    } catch (final InvalidProtocolBufferException e) {
      logger.error("Failed to parse stored session data", e);
      throw new UncheckedIOException(e);
    }
  }
}
